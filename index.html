<!DOCTYPE html>
<html>
  <head>
    <title>Cocoaheads Smalltalk : Tagged Pointers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="remark-0.3.1.min.js" type="text/javascript"></script>
    <style type="text/css" media="screen">
		@import url(http://fonts.googleapis.com/css?family=Arvo:700italic);

		h1, h2 {
		  font-family: 'Arvo';
          font-weight: bold;
		  font-style : italic;
		}
		a {
		  color: #a86;
		  text-decoration: none;
		}
		.center {
		  margin: 0 auto;
		}
		.footnote {
		  position: absolute;
		  bottom: 3em;
		}
		.red {
		  color: #fa0000;
		}
		pre {
		  border-left: 0.4em solid #d7d7d7;
		  padding-left: 0.5em;
		}
		code {
		  background: #f4f4f4 !important;
		}
		.position {
		  visibility: hidden;
		}
		</style>
  </head>
  <body>
    <textarea id="source">


.center.middle
## Cocoaheads Smalltalk
# Tagged Pointers

---

# Principe

En 64-bit sur Intel, les pointeurs sont alignés sur 16 octets.

	.no-highlight
	   6         5         4         3         2         1         0
	3210987654321098765432109876543210987654321098765432109876543210
	............................................................0000

<!--
	* Tagged Pointers : les 4 bits faibles ne sont pas 0
	* Principe assez ancien
	* déjà du temps de System 7
		* par contre, à l'époque, c'étaient de vrais pointeurs 32-bit
	* ici, l'adresse pointée est invalide : la data est dans les 64 bit du pointeurs.
	Avantages :
		* passage par valeur
		* pas de gestion mémoire
-->

---

# Principe

En 64-bit sur Intel, les pointeurs sont alignés sur 16 octets.

	.no-highlight
	   6         5         4         3         2         1         0
	3210987654321098765432109876543210987654321098765432109876543210
	........................................................ccccttt1
	|                                                       |   |  +- 1 bit
	|                                                       |   +---- 3 bits
	|                                                       +-------- 4 bits
	+---------------------------------------------------------------- 56 bits


* 1 bit : flag, 1 pour les tagged pointers
* 7 bits d'infos de type
	* 3 bits pour la classe Objective-C
	<!-- * 8 entrées dans une table statique -->
	* 4 bits d'infos réservés pour la classe
* 56 bits (7 octets) de payload

<!--
	Cela dit, c'est implémenté à relativement au niveau : 
	* pas dans le compilateur,
	* pas dans le système d'allocation mémoire,
	* dans les class CoreFoundation elles-mêmes
	* et dans le runtime ObjC
	* dans CoreFoundation (CFInternal)
		* CFNumber.m
		* CFInternal.h
 -->

---

# CFInternal.h

	.objectivec
	#define CF_IS_TAGGED_OBJ(PTR)	((uintptr_t)(PTR) & 0x1)
	#define CF_TAGGED_OBJ_TYPE(PTR)	((uintptr_t)(PTR) & 0xF)
	 
	enum {
	    kCFTaggedObjectID_Invalid = 0,
	    kCFTaggedObjectID_Undefined0 = (0 << 1) + 1,
	    kCFTaggedObjectID_Integer = (1 << 1) + 1,
	    kCFTaggedObjectID_Undefined2 = (2 << 1) + 1,
	    kCFTaggedObjectID_Undefined3 = (3 << 1) + 1,
	    kCFTaggedObjectID_Undefined4 = (4 << 1) + 1,
	    kCFTaggedObjectID_ManagedObjectID = (5 << 1) + 1, // Core Data
	    kCFTaggedObjectID_Date = (6 << 1) + 1,
	    kCFTaggedObjectID_DateTS = (7 << 1) + 1,
	};

<!--
	* 3 octets donc 8 classes possibles
		* c'est l'implémentation actuelle, on peut changer
		* le bit de poids faible est utilisé comme flag, alors qu'il suffit que le dernier 4-bit ne soit pas 0

	# Aujourd'hui 4 valeurs utilisées
	* enum de CFInternal (slide)
		* NSNUmber (dans CFNumber.c)
		* NSDate (mais pas CFDateRef?)
		* NSDateTimeStamp (?)
		* NSManagedObjectID (pas vu)

 -->

---

# objc-private.h

	.objectivec
	#define OBJC_IS_TAGGED_PTR(PTR)		((uintptr_t)(PTR) & 0x1)
	extern Class _objc_tagged_isa_table[16];

	static inline Class _object_getClass(id obj)
	{
	    if (OBJC_IS_TAGGED_PTR(obj)) {
	        uint8_t slotNumber = ((uint8_t) (uint64_t) obj) & 0x0F;
	        Class isa = _objc_tagged_isa_table[slotNumber];
	        return isa;
	    }
	}

<!-- 
	* _objc_tagged_isa_table : tableau C global de 16 pointeurs vers les structures de Class.
	* en réalité, 8 valeurs utilisés (3 bits) sur les 16, puisque le dernier bit est toujours 1.
 -->

---

# Integers

	.objectivec
	- (void) testSanity
	{
		NSNumber * obj1 = [NSNumber numberWithInt:42];
		NSNumber * obj2 = [NSNumber numberWithInt:42];
		STAssertEqualObjects(obj1, obj2,
							 @"both objects are equal");
	}
	
	- (void) testPointerEquality
	{
		NSNumber * obj1 = [NSNumber numberWithInt:42];
		NSNumber * obj2 = [NSNumber numberWithInt:42];
		STAssertEquals(obj1, obj2,
					   @"both objects are **the same**");
	}
	
	- (void) testPointerValue
	{
		NSNumber * object = [NSNumber numberWithInt:42];
		// shifting the last byte reveals the value
		STAssertEquals(42, (int)((long)object>>8),
					   @"the value is in the pointer");
	}

<!-- 
	* fonctionne avec les entiers de 8 à 64-bit
		* pour les entiers 64-bit, vérifie d'abord si la valeur tient sur les 56 bits de paylod.
	* pas implémenté pour float et double
		* pourquoi? float tiendrait sans hack, et le problème des doubles et réglé pour NSDate
 -->

---

# NSDate

**NSDate <=> NSTimeInterval**

	.objectivec
	typedef union _DoubleOrPointer {
	    NSTimeInterval interval;
	    void * p;
	} DoubleOrPointer;

	- (void) testPointerValue
	{
	    DoubleOrPointer dop = {.interval = 42.0};
	    NSDate * object = [NSDate dateWithTimeIntervalSinceReferenceDate:
						   dop.interval];
	    // Masking out the last byte gives the passed interval
	    STAssertEquals(dop.p, (void*)((long)object&0xFFFFFFFFFFFFFF00),
					   @"the pointer is the value");
	}

<!-- 
	* le double est obtenu en masquant le dernier octet par zero
	* fallback sur un vrai objet si le double ne tient pas sur 56-bit
	* Pas vu dans le source de CFDateRef, qui est pourtant toll-free bridged;
 -->

---

# Links

* objectivistc.tumblr.com
	* [Tagged pointers and fast-pathed CFNumber integers in Lion](http://objectivistc.tumblr.com/post/7872364181/tagged-pointers-and-fast-pathed-cfnumber-integers-in)
	* [A CHOCKING MYSTERY: po [NSNumber numberWithBool:NO] outputs 1](http://objectivistc.tumblr.com/post/8992822737/a-chocking-mystery-po-nsnumber-numberwithbool-no)
* lists.apple.com
	* [Objc-langage](http://lists.apple.com/archives/Objc-language/2011/Nov/msg00014.html)
* opensource.apple.com
	* [ObjC](http://opensource.apple.com/source/objc4/objc4-493.9/)
	* [CoreFoundation](http://opensource.apple.com/source/CF/CF-635/)

<!-- 
	* Philippe Mougin vu sur la liste.
 -->

---

# Bonus #1 : Singleton NSNumbers

	.objectivec
	- (void) testNSNumberSingletons
	{
	    for (int i = -1000; i<=1000; i++) {
	        // NSNumbers between -1 and 12 are singletons
	        if(i>=-1 && i<=12)
	            STAssertTrue( [NSNumber numberWithInt:i]
							  == [NSNumber numberWithInt:i],
	                       	  @"objects should be the same pointer");
	        else
	            STAssertTrue( [NSNumber numberWithInt:i]
					 		  != [NSNumber numberWithInt:i],
	                          @"objects should not be the same pointer");
	    }
	}

<!-- 
	* fonctionne en 32-bit depuis assez longtemps sur Mac, et sur iOS.
 -->

---

# Bonus #2 : objc4/runtime/hashtable2.m

	.objectivec
	/*
		hashtable2.m
	  	Copyright 1989-1996 NeXT Software, Inc.
		Created by Bertrand Serlet, Feb 89
	 */
	
	...

	/**********************************************************************
	 *
	 *	On z'y va
	 *	
	 **********************************************************************/
	
	NXHashTable *NXCreateHashTable (NXHashTablePrototype prototype,
	...
	
<!-- 
	* 1989 !
	* Préfixe NX
	* Legacy code (probablement plus compilé, mais les sources sont encore là)
 -->

---

.footnote[*Made with [remark](gnab.github.com/remark)*]

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
