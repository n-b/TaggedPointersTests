<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="https://github.com/downloads/gnab/remark/remark-0.3.1.min.js" type="text/javascript"></script>
    <style type="text/css" media="screen">
      /* Slideshow styles */
    </style>
  </head>
  <body>
    <textarea id="source">

.center.middle
# Cocoaheads smalltalk : Tagged Pointers

---

# principe général tagged pointers

* pointeurs en 64-bit alignés sur 16 octets
	* les 4 bits faibles sont à 0
	* tagged pointers : les 4 bits faibles ne sont pas 0
* pas nouveau : les vieux dev mac utilisaient déjà ça
	* par conte, différence importante : c'était vraiment des flags sur des vrais pointeurs.
	* Ici, l'adresse pointée est invalide : la data est dans les 64 bit du pointeurs.

---

# principe technique (animations sur les bitfields)

<table style='margin-left: auto;
margin-right: auto;
'>
	<tr>
		<td>1</td> <td>2</td>
	</tr>
</table>

| 1 | 2 |
|===|===|
| a | b |

* dernier octet utilisé pour metadata
	* 1 bit : flag
	* 7 bits d'infos de type
		* 3 bits de classe
			* 8 entrées dans une table statique
		* 4 bits d'infos réservés pour la classe
* 7 octets (56 bits) de payload

---

# intérêt (slide)

* passage par valeur
* pas de gestion mémoire

---

# implémenté à relativement au niveau :

* pas dans le compilateur,
* dans le runtime ObjC
* dans CoreFoundation (CFInternal)
	* CFNumber.m
	* CFInternal.h

---

# 3 octets donc 8 classes possibles

* c'est l'implémentation actuelle, on peut changer
	* le bit de poids faible est utilisé comme flag, alors qu'il suffit que le dernier 4-bit ne soit pas 0
	* _objc_tagged_isa_table : tableau C global de 16 pointeurs vers les structures de Class.
		* en réalité, 8 valeurs utilisés (3 bits)

---

# Aujourd'hui 4 valeurs utilisées
* enum de CFInternal (slide)
	* NSNUmber (dans CFNumber.c)
	* NSDate (mais pas CFDateRef?)
	* NSDateTimeStamp (?)
	* NSManagedObjectID (pas vu)

---

# - [NSNumber numberWithInt:]

illustration sur un int (décalage pour obtenir la valeur)
en décalant (>>8) les 56 bits, on obtient un int
* fonctionne avec numberWithShort:, numberWithLong, numberWithLongLong.
	* pour numberWithLongLong, vérifie d'abord si la valeur tient sur 56 bits.
* pas implémenté pour numberWithFloat et numberWithDouble
	* pourquoi? float tiendrait sans hack, et le problème des doubles et réglé pour NSDate

---

# illustration sur NSDate (extraits code)

* NSDate est sémantiquement équivalent à NSTimeInterval (double)
* le double est obtenu en masquant le dernier octet par zero
* fallback sur un vrai objet si le double ne tient pas sur 56-bit

---

# Bonus #1 : singleton NSNumbers

---

# Bonus #2 : source code by bertrand serlet
* wonderful old code by bertrand serlet in (http://opensource.apple.com/source/objc4/objc4-493.9/runtime/hashtable2.m?txt)

---

# Links
* [discussion sur lists.apple.com/Objc-langage](http://lists.apple.com/archives/Objc-language/2011/Nov/msg00014.html)
* (http://objectivistc.tumblr.com/post/7872364181/tagged-pointers-and-fast-pathed-cfnumber-integers-in)
* (http://objectivistc.tumblr.com/post/8992822737/a-chocking-mystery-po-nsnumber-numberwithbool-no)
* http://opensource.apple.com/source/objc4/objc4-493.9/
* http://opensource.apple.com/source/CF/CF-635/

---

.center.middle

# Thanks

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
